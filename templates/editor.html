{% extends "base.html" %}

{% block title %}Editor ¬∑ {{ page_path }} ¬∑ Tetris Guide{% endblock %}

{% block content %}
<div class="editor-layout" id="editor-layout" style="grid-template-columns: minmax(0, 1.1fr) 6px minmax(0, 1.3fr);">
  <section class="editor-panel">
    <h1 class="editor-title">Editor Source: {{ page_path }}/page.txt</h1>
    <textarea class="editor-textarea" id="editor-textarea">{{ raw_content }}</textarea>
    <div class="editor-actions">
      <button class="editor-save-btn" id="editor-save-btn">Save</button>
      <span class="editor-status" id="editor-status"></span>
    </div>
  </section>

  <div class="editor-resizer" id="editor-resizer"></div>

  <section class="preview-panel">
    <h1 class="editor-title">Preview</h1>
    <div class="page-wrapper">
      <div class="page-inner">
        {{ rendered_content | safe }}
      </div>
    </div>
    {% if sources %}
    <section class="sources-panel">
      <div class="sources-title">Sources</div>
      {% for s in sources %}
      <div class="source-item">
        {{ s.label }} - <a href="{{ s.url }}" target="_blank" rel="noopener">{{ s.url }}</a>
      </div>
      {% endfor %}
    </section>
    {% endif %}
  </section>
</div>

<script>
  (function () {
    const layout = document.getElementById("editor-layout");
    const handle = document.getElementById("editor-resizer");
    if (!layout || !handle) return;

    let isDragging = false;

    handle.addEventListener("mousedown", (e) => {
      isDragging = true;
      document.body.style.cursor = "col-resize";
      e.preventDefault();
    });

    document.addEventListener("mouseup", () => {
      if (!isDragging) return;
      isDragging = false;
      document.body.style.cursor = "";
    });

    document.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      const rect = layout.getBoundingClientRect();
      const totalWidth = rect.width;
      const offsetX = e.clientX - rect.left;
      const minPct = 0.2;
      const maxPct = 0.8;
      let leftPct = offsetX / totalWidth;
      if (leftPct < minPct) leftPct = minPct;
      if (leftPct > maxPct) leftPct = maxPct;
      const rightPct = 1 - leftPct;
      layout.style.gridTemplateColumns = `minmax(0, ${leftPct}fr) 6px minmax(0, ${rightPct}fr)`;
    });
  })();

  // Page text editor save
  (function() {
    const textarea = document.getElementById('editor-textarea');
    const saveBtn = document.getElementById('editor-save-btn');
    const status = document.getElementById('editor-status');
    
    if (!textarea || !saveBtn) return;
    
    let originalContent = textarea.value;
    
    saveBtn.addEventListener('click', async () => {
      const content = textarea.value;
      try {
        const response = await fetch('/api/page/save', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            page_path: '{{ page_path }}',
            content: content
          })
        });
        
        const result = await response.json();
        if (result.success) {
          originalContent = content;
          status.textContent = 'Saved';
          status.style.color = '#22c55e';
          setTimeout(() => {
            status.textContent = '';
          }, 2000);
          window.location.reload();
        } else {
          status.textContent = 'Error: ' + (result.message || 'Unknown error');
          status.style.color = '#ef4444';
        }
      } catch (error) {
        status.textContent = 'Error: ' + error.message;
        status.style.color = '#ef4444';
      }
    });
  })();

  // Board editor functionality
  (function() {
    const TETRIS_PIECES = ['i', 'o', 't', 's', 'z', 'j', 'l'];
    let selectedPiece = 'i';
    let isMouseDown = false;
    let mouseButton = 0; // 0 = left, 2 = right
    let currentBoardId = null;
    let originalGrid = null;
    let currentModal = null;
    let currentBoardContainer = null;
    let mode = 'draw'; // 'draw' or 'select'
    let selection = null; // {startRow, startCol, endRow, endCol}
    let clipboard = null;

    // Handle dropdown menu
    document.addEventListener('click', (e) => {
      const toggle = e.target.closest('.board-dropdown-toggle');
      const menu = e.target.closest('.board-dropdown-menu');
      const item = e.target.closest('.board-dropdown-item');
      
      // Close all menus
      document.querySelectorAll('.board-dropdown-menu').forEach(m => {
        if (m !== menu && !m.contains(e.target)) {
          m.style.display = 'none';
        }
      });

      if (toggle) {
        e.stopPropagation();
        const dropdown = toggle.closest('.board-dropdown');
        const menuEl = dropdown?.querySelector('.board-dropdown-menu');
        if (menuEl) {
          menuEl.style.display = menuEl.style.display === 'none' ? 'block' : 'none';
        }
      }

      if (item && item.dataset.action === 'edit') {
        e.stopPropagation();
        const boardId = item.dataset.boardId;
        openEditModal(boardId);
        // Close menu
        const menuEl = item.closest('.board-dropdown-menu');
        if (menuEl) menuEl.style.display = 'none';
      }
    });

    function openEditModal(boardId) {
      // Find the board element to get current state
      const boardEl = document.querySelector(`[data-board-id="${boardId}"]`);
      if (!boardEl) return;

      currentBoardId = boardId;
      
      // Extract current grid state from data-grid attribute if available, otherwise from cells
      const gridAttr = boardEl.getAttribute('data-grid');
      if (gridAttr) {
        originalGrid = gridAttr.split('|');
      } else {
        originalGrid = [];
        const rowElements = boardEl.querySelectorAll('.tetris-row');
        rowElements.forEach(rowEl => {
          const cells = rowEl.querySelectorAll('.tetris-cell');
          let rowStr = '';
          cells.forEach(cell => {
            const piece = cell.dataset.piece || '';
            const classes = cell.className;
            if (classes.includes('cell-i')) rowStr += 'i';
            else if (classes.includes('cell-o')) rowStr += 'o';
            else if (classes.includes('cell-t')) rowStr += 't';
            else if (classes.includes('cell-s')) rowStr += 's';
            else if (classes.includes('cell-z')) rowStr += 'z';
            else if (classes.includes('cell-j')) rowStr += 'j';
            else if (classes.includes('cell-l')) rowStr += 'l';
            else rowStr += '_';
          });
          originalGrid.push(rowStr);
        });
      }
      
      // Ensure we have 20 rows
      while (originalGrid.length < 20) {
        originalGrid.push('__________');
      }
      originalGrid = originalGrid.slice(0, 20);

      // Create modal
      const modal = document.createElement('div');
      modal.className = 'board-edit-modal';
      modal.innerHTML = `
        <div class="board-edit-modal-content">
          <div class="board-edit-modal-header">
            <h2>Edit Board</h2>
            <button class="board-edit-modal-close" type="button">&times;</button>
          </div>
          <div class="board-edit-modal-body">
            <div class="board-edit-tools">
              <button class="board-tool-btn ${mode === 'draw' ? 'active' : ''}" data-tool="draw" title="Brush Tool">üñåÔ∏è</button>
              <button class="board-tool-btn ${mode === 'select' ? 'active' : ''}" data-tool="select" title="Select Tool">üî≤</button>
              <div class="board-edit-color-picker">
                ${TETRIS_PIECES.map(piece => 
                  `<div class="board-edit-color-cell cell-${piece}${piece === selectedPiece ? ' selected' : ''}" data-piece="${piece}"></div>`
                ).join('')}
              </div>
            </div>
            <div class="board-edit-board-container">
              <div class="board-edit-board" id="board-edit-board"></div>
            </div>
          </div>
          <div class="board-edit-modal-footer">
            <button class="board-save-btn" type="button">Save</button>
            <button class="board-cancel-btn" type="button">Cancel</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
      modal.style.display = 'flex';
      currentModal = modal;
      modal.setAttribute('tabindex', '0');
      modal.focus();
      
      // Render board immediately with existing data
      const boardContainer = modal.querySelector('#board-edit-board');
      currentBoardContainer = boardContainer;
      if (boardContainer) {
        // Ensure we have grid data
        if (!originalGrid || originalGrid.length === 0) {
          originalGrid = Array(20).fill('__________');
        }
        renderBoardInModal(boardContainer, originalGrid);
        
        // Make cells editable after rendering
        setTimeout(() => {
          setupBoardEditing(boardContainer);
        }, 10);
      }

      // Prevent context menu in entire modal
      const preventContextMenu = (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      };
      modal.addEventListener('contextmenu', preventContextMenu);
      modal.addEventListener('selectstart', preventContextMenu);

      // Tool selection
      modal.querySelectorAll('.board-tool-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          mode = btn.dataset.tool;
          modal.querySelectorAll('.board-tool-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          clearSelection();
        });
      });

      // Color picker selection
      modal.querySelectorAll('.board-edit-color-cell').forEach(cell => {
        cell.addEventListener('click', () => {
          selectedPiece = cell.dataset.piece;
          modal.querySelectorAll('.board-edit-color-cell').forEach(c => c.classList.remove('selected'));
          cell.classList.add('selected');
          // Switch to draw mode when selecting color
          mode = 'draw';
          modal.querySelectorAll('.board-tool-btn').forEach(b => b.classList.remove('active'));
          modal.querySelector('[data-tool="draw"]')?.classList.add('active');
          clearSelection();
        });
      });

      // Keyboard shortcuts - attach to modal and make it focusable
      modal.setAttribute('tabindex', '-1');
      modal.addEventListener('keydown', handleKeyboardShortcuts);
      modal.focus();

      // Close button
      modal.querySelector('.board-edit-modal-close').addEventListener('click', () => {
        closeModal(modal);
      });

      // Cancel button
      modal.querySelector('.board-cancel-btn').addEventListener('click', () => {
        closeModal(modal);
      });

      // Save button
      modal.querySelector('.board-save-btn').addEventListener('click', () => {
        saveBoardFromModal(modal);
      });

      // Close on backdrop click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeModal(modal);
        }
      });
    }

    function renderBoardInModal(container, grid) {
      container.innerHTML = '';
      container.className = 'tetris-board';
      
      grid.forEach(row => {
        const rowEl = document.createElement('div');
        rowEl.className = 'tetris-row';
        
        const rowPadded = row.padEnd(10, '_').substring(0, 10);
        for (let i = 0; i < 10; i++) {
          const ch = rowPadded[i] || '_';
          const cell = document.createElement('div');
          cell.className = 'tetris-cell';
          if (ch !== '_' && TETRIS_PIECES.includes(ch)) {
            cell.className = `tetris-cell cell-${ch}`;
            cell.dataset.piece = ch;
          } else {
            cell.className = 'tetris-cell cell-empty';
            cell.dataset.piece = '';
          }
          rowEl.appendChild(cell);
        }
        container.appendChild(rowEl);
      });
    }

    function setupBoardEditing(container) {
      const cells = container.querySelectorAll('.tetris-cell');
      cells.forEach((cell, index) => {
        const row = Math.floor(index / 10);
        const col = index % 10;
        cell.dataset.row = row;
        cell.dataset.col = col;
        
        cell.addEventListener('mousedown', (e) => handleCellMouseDown(e, cell, row, col));
        cell.addEventListener('mouseenter', (e) => handleCellMouseEnter(e, cell, row, col));
        const preventContext = (e) => {
          e.preventDefault();
          e.stopPropagation();
          return false;
        };
        cell.addEventListener('contextmenu', preventContext);
        cell.addEventListener('selectstart', preventContext);
      });
    }

    function handleCellMouseDown(e, cell, row, col) {
      e.preventDefault();
      e.stopPropagation();
      isMouseDown = true;
      mouseButton = e.button;
      
      if (mode === 'select') {
        selection = { startRow: row, startCol: col, endRow: row, endCol: col };
        updateSelection();
      } else if (mode === 'draw') {
        if (mouseButton === 0) {
          fillCell(cell);
        } else if (mouseButton === 2) {
          deleteCell(cell);
        }
      }
    }

    function handleCellMouseEnter(e, cell, row, col) {
      lastMouseCell = cell;
      if (!isMouseDown) return;
      e.preventDefault();
      e.stopPropagation();
      
      if (mode === 'select') {
        if (selection) {
          selection.endRow = row;
          selection.endCol = col;
          updateSelection();
        }
      } else if (mode === 'draw') {
        if (mouseButton === 0) {
          fillCell(cell);
        } else if (mouseButton === 2) {
          deleteCell(cell);
        }
      }
    }

    function fillCell(cell) {
      cell.className = `tetris-cell cell-${selectedPiece}`;
      cell.dataset.piece = selectedPiece;
    }

    function deleteCell(cell) {
      cell.className = 'tetris-cell cell-empty';
      cell.dataset.piece = '';
    }

    document.addEventListener('mouseup', () => {
      isMouseDown = false;
    });

    function closeModal(modal) {
      modal.style.display = 'none';
      modal.remove();
      currentBoardId = null;
      originalGrid = null;
      currentModal = null;
      currentBoardContainer = null;
      clearSelection();
    }

    function updateSelection() {
      if (!selection || !currentBoardContainer) return;
      const cells = currentBoardContainer.querySelectorAll('.tetris-cell');
      cells.forEach(cell => {
        cell.classList.remove('selected');
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        const minRow = Math.min(selection.startRow, selection.endRow);
        const maxRow = Math.max(selection.startRow, selection.endRow);
        const minCol = Math.min(selection.startCol, selection.endCol);
        const maxCol = Math.max(selection.startCol, selection.endCol);
        if (row >= minRow && row <= maxRow && col >= minCol && col <= maxCol) {
          cell.classList.add('selected');
        }
      });
    }

    function clearSelection() {
      selection = null;
      if (currentBoardContainer) {
        currentBoardContainer.querySelectorAll('.tetris-cell').forEach(cell => {
          cell.classList.remove('selected');
        });
      }
    }

    function copySelection() {
      if (!selection || !currentBoardContainer) return;
      const minRow = Math.min(selection.startRow, selection.endRow);
      const maxRow = Math.max(selection.startRow, selection.endRow);
      const minCol = Math.min(selection.startCol, selection.endCol);
      const maxCol = Math.max(selection.startCol, selection.endCol);
      
      const rows = currentBoardContainer.querySelectorAll('.tetris-row');
      clipboard = [];
      for (let r = minRow; r <= maxRow; r++) {
        const row = [];
        const cells = rows[r].querySelectorAll('.tetris-cell');
        for (let c = minCol; c <= maxCol; c++) {
          const piece = cells[c].dataset.piece || '';
          row.push(piece || '_');
        }
        clipboard.push(row);
      }
    }

    function pasteAt(row, col) {
      if (!clipboard || !currentBoardContainer) return;
      const rows = currentBoardContainer.querySelectorAll('.tetris-row');
      clipboard.forEach((clipRow, r) => {
        const targetRow = row + r;
        if (targetRow >= 0 && targetRow < 20) {
          const cells = rows[targetRow].querySelectorAll('.tetris-cell');
          clipRow.forEach((piece, c) => {
            const targetCol = col + c;
            if (targetCol >= 0 && targetCol < 10) {
              const cell = cells[targetCol];
              if (piece === '_') {
                deleteCell(cell);
              } else {
                selectedPiece = piece;
                fillCell(cell);
              }
            }
          });
        }
      });
    }

    function deleteSelection() {
      if (!selection || !currentBoardContainer) return;
      const minRow = Math.min(selection.startRow, selection.endRow);
      const maxRow = Math.max(selection.startRow, selection.endRow);
      const minCol = Math.min(selection.startCol, selection.endCol);
      const maxCol = Math.max(selection.startCol, selection.endCol);
      
      const rows = currentBoardContainer.querySelectorAll('.tetris-row');
      for (let r = minRow; r <= maxRow; r++) {
        const cells = rows[r].querySelectorAll('.tetris-cell');
        for (let c = minCol; c <= maxCol; c++) {
          deleteCell(cells[c]);
        }
      }
      clearSelection();
    }

    let lastMouseCell = null;

    function handleKeyboardShortcuts(e) {
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'c' && selection) {
          e.preventDefault();
          copySelection();
        } else if (e.key === 'v' && clipboard) {
          e.preventDefault();
          if (lastMouseCell) {
            const row = parseInt(lastMouseCell.dataset.row);
            const col = parseInt(lastMouseCell.dataset.col);
            pasteAt(row, col);
          } else {
            pasteAt(0, 0);
          }
        }
      } else if (e.key === 'Delete' && selection) {
        e.preventDefault();
        deleteSelection();
      }
    }

    async function saveBoardFromModal(modal) {
      if (!currentBoardId) return;
      
      const boardEl = modal.querySelector('#board-edit-board');
      const rows = [];
      const rowElements = boardEl.querySelectorAll('.tetris-row');
      
      rowElements.forEach(rowEl => {
        const cells = rowEl.querySelectorAll('.tetris-cell');
        let rowStr = '';
        cells.forEach(cell => {
          const piece = cell.dataset.piece || '';
          rowStr += piece || '_';
        });
        rows.push(rowStr);
      });

      try {
        const response = await fetch('/api/board/save', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            board_id: currentBoardId,
            grid: rows
          })
        });

        const result = await response.json();
        if (result.success) {
          closeModal(modal);
          window.location.reload();
        }
      } catch (error) {
        console.error('Error saving board:', error);
      }
    }
  })();
</script>
{% endblock %}

